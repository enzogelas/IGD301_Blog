<head>
    <title>Blog for IGD301 - Enzo GELAS</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <nav id="navigation">
        <a href="#title" class="navigation-link">Home</a>
        <h6 class="navigation-title">Homeworks</h6>
        <a href="#homework-1" class="navigation-link">Homework 1</a>
        <a href="#homework-2" class="navigation-link">Homework 2</a>      
        <a href="#homework-3" class="navigation-link">Homework 3</a>        
        <h6 class="navigation-title">Labs</h6>
        <a href="#lab-1" class="navigation-link">Lab 1</a>        
        <a href="#lab-2" class="navigation-link">Lab 2</a> 
    </nav>

    <div id="MAIN_DIV">

    <h1 id="title">Blog for IGD301</h1>
    <h2 id="author">Enzo GELAS</h2>
    <div id="homework-1" class="work">
        <h3>Homework 1</h3>
        <h4>VR Fails video</h4>
        <h5>First scenario</h5>
        <p>Let’s consider a VR game when you have to avoid projectiles to win.
            When you have to walk in a VR environment, there’s a risk to run into walls or different objects. This type of accident, present from the very first seconds of the video, is probably the most frequent.</p>
        <p>Solution :</p>
        <ul>
            <li>(Pragmatical solution) Before the game, ask the player to keep out the objects that could cause problems, like tables, chairs or decorations. </li>
            <li>(Technological solution) Create a functionality that allows players to map the walls before playing. For example, he could walk along the walls with a controller, and the program store the position of the walls in memory. In game, if the player comes too close to a wall (closer than a distance chosen by the player), the game can display the walls in a very striking color or a characteristic pattern</li>
        </ul>
        <img src="images/scenario1.jpg" width="500px" height="200px">

        <h5>Second scenario</h5>
        <p>For the second scenario, let’s consider sports games. In these games, you can practice boxing, bowling, golf, football, ... You may have to perform large movements with your legs and/or arms. This can lead to accidental injury to humans or animals passing close to the player.</p>
        <p>Solution :</p>
        <ul>
            <li>(Pragmatical solution) Limit you playing area with physical barriers to prevent people from coming in</li>
            <li>(Technological solution) The headset could use sensor to detect moving bodies close to the player. When this happens, the headset informs the player by triggering a buzzing sound and displaying an alert in the field of vision at the position of the object with its distance to the player.</li>
        </ul>
        <img src="images/scenario2.jpg" width="500px" height="200px">  
        <h4>The CAVE system</h4>
        <h5>Presentation and comparison with Head-Mounted displays</h5>
        <p>Unlike Head-Mounted displays, the CAVE system does not cover the eyes of the user. It just displays the virtual environment of the user on fixed screens, and not in a headset. The user can move in a fixed area and see all physical objects in it, including its own body. This technology can take into account the orientation of the player's head thanks to a device placed on the user.</p>
        <p>Advantages of the CAVE system :</p>
        <ul>
            <li>Cause the user can see his own body, the walls and the objects present in the room, he can walks freely without risking to bump into surrounding obstacles. The “VR fails” video shows us that this risk is not absent from Head-Mounted displays”</li>
            <li>The users is in a specialized isolated room, and so experiences without external perturbations. </li>
            <li>As explained in the paper, as VR technologies, the CAVE system allow the user to see virtual objects at different angles, what increases the realism of the experience.</li>
        </ul>
        <p>Disadvantages of the CAVE system :</p>
        <ul>
            <li>Because the eyes are not completely covered, the user is always conscient that he’s in a real physical room. It could tend to reduce the suspension of disbelief.</li>
            <li>As mentioned in the paper, the physical objects present in the CAVE room can prevent the user from viewing virtual items even if they’re supposed to be closer to him. This problem isn't present in Head-Mounted devices cause all is virtual in this type of technology.</li>
        </ul>
        <p>Common disadvantages with VR headsets :</p>
        <ul>
            <li>Both CAVE and Head-Mounted technologies suffer from visual acuity of what is displayed. For the CAVE system, the difference of acuity between your own body, that you see directly, and the virtual items displayed can be even more uncomfortable.</li>
        </ul>
        <h5>Position in the Reality-Virtuality Continuum</h5>
        <p>
            About the place of the CAVE system in the Reality-Virtuality Continuum
            In the Cave system, the user sees all objects present in the room he is. The rest is displayed on screen. This should lead us to think of it as augmented reality.
            However, virtual items are displayed in all direction, providing more virtuality than usual augmented reality technologies, that only include a few virtual items in the real world.
            For these reasons, the CAVE system should be located between Augmented Reality and Augmented Virtuality.
        </p>
        <img src="images/CAVE_position.png" width="1000px" height="100px">
        <p>
            When more people are experiencing the CAVE system at the same time, they can interact between them. This adds more place for real interactions to the experience. 
            Thus, the CAVE system should be considered closer to the Augmented Reality :
        </p>
        <img src="images/CAVE_position_several_people.png" width="1000px" height="120px">
    </div>
    <div id="homework-2" class="work">
        <h3>Homework 2</h3>
        <h4>VR Selection Techniques</h4>
        <p>The goal of this homework is to present 3 different VR selection techniques and classify them.</p>
        <h5>FistPointer</h5>
        <p>I saw this selection technique on this <a href="https://www.youtube.com/watch?v=Bg-5qlV5BXg&t=22s&pp=ygULZmlzdHBvaW50ZXI%3D">video</a>. 
        It comes from the paper : <em>"FistPointer: Target Selection Technique using Mid-air Interaction for Mobile VR Environment"</em> (Unfortunately, I did not find a free access to the PDF.)
        </p>
        <p>This technique has been designed for use in a mobile VR environment, where there is no hand controller. The user moves his hands, with thumbs up, to control the point to target on the screen. When he's satisfied, he lowers his his thumb to confirm.</p>
        <img src="images/fistPointer_thumbUp.png">
        <img src="images/fistPointer_thumbDown.png">
        <ul>
            <li>Reach : Cause this technique is made for 2D environment, it's not relevant to talk about selection reach.</li>
            <li>Cardinality : Single. The FistPointer only concerns the object present under the controlled target.</li>
            <li>Refinement : There is no refinement.</li>
        </ul>
        <h5>GazeRayCursor</h5>
        <p>
            This selection techniques comes from the paper : <a href="https://dl.acm.org/doi/pdf/10.1145/3611659.3615693?casa_token=k7wS2QAM47sAAAAA:FJ0d-FPuO1VsFpmUdh0IdojVrrslv9ce3kjx1Q6JPA1aXKCdOxexUnan3zLaBdeDAKcMxXJNqkY" style="text-decoration: none; font-style: italic;">"GazeRayCursor: Facilitating Virtual Reality Target Selection by Blending Gaze and Controller Raycasting"</a>
            and is presented in this <a href="https://www.youtube.com/watch?v=wJgQk9NcqWM&t=83s&pp=ygUNZ2F6ZXJheWN1cnNvcg%3D%3D">video</a>.
        </p>
        <p>The idea is to combine gaze direction and ray direction casted by the controller to determine the targeted point.</p>
        <img src="images/gazeRayCursor.png">
        <p>The controller cast a ray and the user moves his eyes to adjust the selction along this ray by looking more or less far. In the following image, we see the ray casted and the red point represent the guessed intersection point between this ray and the user's gaze.</p>
        <img src="images/gazeRayCursor-example.png">
        <ul>
            <li>Reach : Infinite. The reach is infinite, like in standard raycasting. It is even less limited than this cause it overcomes occlusion of far objects.</li>
            <li>Cardinality : Single.</li>
            <li>Refinement : There is a continuous refinement. In the video, we see that the user can adjust his controller and gaze until the right object is selected.</li>
        </ul>
        <h5>Slicing Volume</h5>
        <p>
            This selection techniques comes from the paper : <a href="https://discovery.ucl.ac.uk/id/eprint/10107943/1/Slicing-Volume_IEEEVR20.pdf" style="text-decoration: none; font-style: italic;">"Slicing-Volume: Hybrid 3D/2D Multi-target Selection Technique for
                Dense Virtual Environments "</a>
            and is presented in this <a href="https://www.youtube.com/watch?v=yULQYJzEqv4&t=48s&pp=ygURc2xpY2luZyB2b2x1bWUgdnI%3D">video</a>.
        </p>
        <p>
            The idea is to select all elements in a parallelepiped. The dimensions of this parallelepiped can be adjusted by the user.
        </p>
        <img src="images/slicingVolume-tablet.jpg">
        <p>The user can then move the tablet and visualize what's inside the parallelepiped.</p>
        <img src="images/slicingVolume-example.jpg">
        <ul>
            <li>Reach : Scaled. The virtual tablet to select the volume is held by hand, but the user can modify the dimensions of the selection parallelepiped.</li>
            <li>Cardinality : Multiple. All elements in the parallelepiped are selected.</li>
            <li>Refinement : There is a continuous refinement. The position and the dimensions of the parallelepiped can be adjusted at every moment. We could even talk about a "continuous selection"</li>
        </ul>
    </div>
    <div id="homework-3" class="work">
        <h3>Homework 3</h3>
        <h4>VR Navigation Pitch</h4>
        <p>For this homework, we have to prepare a 5-minute presentation about a <b>novel locomotion technique</b> in VR. This technique doesn't need to be realistic and we won't have to implement it.</p>
        <p> You can see the presentation slides on <a href="https://www.canva.com/design/DAGY5M3aavE/BIcJV7x9PDvjFsYRBFMRlQ/edit?utm_content=DAGY5M3aavE&utm_campaign=designshare&utm_medium=link2&utm_source=sharebutton"> this</a>.</p>
        <h5>Explanation of the technique</h5>
        <p>My locomotion technique is a plank on wheels controlled with a thruster and a handbreak.</p>
        <img src="images/locomotion_elements.png">
        <p>The character uses the thruster to move forward and the handbreak to slow and stop the plank</p>
        <img src="images/locomotion_movement1.png">
        <img src="images/locomotion_break.png">
        <p>I found two situations where this locomotion technique can be used</p>
        <ul>
            <li>A race game : This is a fun and novel vehicle for races</li>
            <li>As a vehicle in an open world game (like GTA)</li>
        </ul>
    </div>
    <div id="lab-1" class="work">
        <h3>Lab 1</h3>
        <h4>Setting up the blog</h4>
        <p>To create my blog, I first wanted to use hugo as adviced by the course. 
            I finally prefered to do the blog in my own html/css because I already knew quite a bit about these languages.
            The style is simple, with a navigation bar on the left and the content on the right, all in a single page.
        </p>
        <p>
            To host this blog on the Internet, I quickly considered to use GitHub pages. I'm already using GitHub for a couple of years and it was for me the simplest solution.
            So I read the <a href="https://docs.github.com/en/pages">tutorials</a> (+ some precisions on the Internet) and I was done pretty easily.
        </p>
        <h4>Setting up the Unity environment</h4>
        <p>
            I never used Unity or similar tool (I've heard of Godot but I never used it) before. Howerver, the setup was not very hard. The tutorial given by the professor was clear and straight.
            The interface of Unity Hub is intuitive. I easily installed the last version with required modules.
        </p>
        <img src="images/unity_setup_hub_homepage.jpg">
        <p>I never used the Unity editor before, so I created a new universal 3D project and followed the <a href="https://learn.unity.com/tutorial/get-started-with-the-unity-editor#">introduction tutorial for the Unity editor</a> in preparation to the next Lab.</p>
        <img src="images/unity_hub_create_first_project.jpg">
        <p>It helped me to learn how to navigate into the Unity editor, create new objects in my scene, apply physics, add characters and objects (The tutorial gives a lot of prefabs to fill the scene)</p>
        <img src="images/unity_first_tutorial.jpg">
    </div>
    <div id="lab-2" class="work">
        <h3>Lab 2</h3>
        <h4>Roll-a-Ball game</h4>
        <p>
            For this second lab, we had to create a simple Roll-a-Ball game by following the <a href="https://learn.unity.com/project/roll-a-ball">tutorial</a> on the Unity website. 
            I'll depict the different steps I followed to create the game.
        </p>

        <h5>Step 1 : Set up the environment</h5>
        <p>
            I created a new 3D project using the universal 3D template.
        </p>
        <img src="images/lab2-step1-createProject.jpg">
        <p>Here is the list of my projects after creating this one.</p>
        <img src="images/lab2-step1-listOfProjects.jpg">
        <p>Once in my newly created project, the tutorial suggest us to choose the default layout of the editor, suitable for beginners.</p>
        <p>
            Then, we must create our scene and add the first objects in it : the ground (a plane) and the player (a sphere).
            We also have to create materials to give them a color and an aspect. We basically just choose the color (Base Map) and the smoothness of the material, as shown in the following image :
        </p>
        <img src="images/lab2-step1-createMaterial.jpg">
        <p>We then apply it by dragging it on the object.</p>

        <h5>Step 2 : Move the Player</h5>
        <p>In this step, we learn how to move the player by writing our first C# scripts.</p>
        <p>First, our player has to be considered as a rigid body, so we must add a RigidBody component to it so we can later apply forces to it.</p>
        <img src="images/lab2-step2-addRigidBody.jpg">
        <p>We must then add an Input Player component to acces to key actions. Finally, we write a script to retrieve key actions and apply forces to the player in consequence.</p>
        <video src="videos/lab2-step2-demo.mp4" controls></video>

        <h5>Step 3 : Move the camera</h5>
        <p>The goal of this step is to place the camera as we want and write a new script to adapt the camera movement to the player movement.</p>
        <video src="videos/lab2-step3-demo.mp4" controls></video>

        <h5>Step 4 : Set up the play area</h5>
        <p>In this step, we add walls to define the play area.</p>
        <video src="videos/lab2-step4-demo.mp4" controls></video>

        <h5>Step 5 : Create collectibles</h5>
        <p>We start to implement the mechanics of the game. The player will have to collect pickups to win. So we start by adding them to the game area. We also them an rotating animation.</p>
        <video src="videos/lab2-step5-demo1.mp4" controls></video>
        <p>We then add conditions to make the collectibles disappear on collision.</p>
        <video src="videos/lab2-step5-demo2.mp4" controls></video>

        <h5>Step 6 : Display score and text</h5>
        <p>We want to display the number of pickups the player has to collect to win, and text for win.</p>
        <video src="videos/lab2-step6-demo.mp4" controls></video>

        <h5>Step 7 : Create an ennemy</h5>
        <p>On this almost last step, we want to create an ennemy that chases the player.</p>
        <video src="videos/lab2-step7-chase.mp4" controls></video>
        <p>Then, we add more obstacles (static or dynamic) and refine the scripts so the player loses when the enemy catches it. And here is the final game :</p>
        <video src="videos/lab2-finalGame.mp4" controls></video>

        <h5>Step 8 : Build the game</h5>
        <p>The very last step is to build the game for the computer. For that, we follow the instructions in the Unity tutotrial.</p>
    </div>

    </div>
</body>
